{
  "version": 3,
  "sources": ["../../node_modules/use-error-boundary/src/ErrorBoundary.ts", "../../node_modules/use-error-boundary/src/use-error-boundary.ts", "../../node_modules/use-error-boundary/src/create-error-boundary.ts"],
  "sourcesContent": ["import { PureComponent } from \"react\"\n\nexport type ErrorObject = {\n  error: any\n}\n\n/**\n * Internal callback, used to link the hook state to the boundary state.\n */\nexport type OnDidCatchCallback = (error: any, errorInfo: any) => void\n\n/**\n * Props of the internal ErrorBoundary component.\n *\n * onDidCatch is used internally.\n * children, render and renderError are public facing and get utilized by the UseErrorBoundaryWrapper.\n */\nexport interface ErrorBoundaryProps {\n  onDidCatch: OnDidCatchCallback\n  children?: React.ReactNode | JSX.Element\n  render?: () => React.ReactNode | JSX.Element\n  renderError?: (error: ErrorObject) => React.ReactNode | JSX.Element\n}\n\n/**\n * Internal ErrorBoundary state.\n */\nexport interface ErrorBoundaryState {\n  hasError: boolean\n  error: any\n}\n\n/**\n * ErrorBoundary class\n *\n * Catches errors using lifecycle methods and renders fallback ui using children or render props.\n */\nexport class ErrorBoundary extends PureComponent<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  /**\n   * Initialize component state.\n   */\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n\n    this.state = {\n      hasError: false,\n      error: null,\n    }\n  }\n\n  /**\n   * Set error state when the boundary catches.\n   */\n  static getDerivedStateFromError(error: any) {\n    return { hasError: true, error }\n  }\n\n  /**\n   * Use componentDidCatch lifecycle method to report the error using\n   * the onDidCatch prop.\n   */\n  componentDidCatch(error: any, errorInfo: any) {\n    return this.props.onDidCatch(error, errorInfo)\n  }\n\n  /**\n   * Render children or fallback ui depending on the error state.\n   *\n   * Uses render props api if either render or renderError is defined.\n   */\n  render() {\n    const { hasError, error } = this.state\n    const { render, children, renderError } = this.props\n\n    // Prevent rendering of children that caused the error, render fallbacks instead\n    if (hasError) {\n      // Render either components from renderError() or nothing\n      return renderError ? renderError({ error }) : null\n    }\n\n    // Render either components from render() or children or null\n    return render ? render() : children || null\n  }\n}\n", "import React, { useRef, useReducer, useCallback } from \"react\"\n\nimport {\n  createErrorBoundary,\n  UseErrorBoundaryWrapper,\n} from \"./create-error-boundary\"\n\nexport interface ErrorState {\n  didCatch: boolean\n  error: any | null\n}\n\nexport interface UseErrorBoundaryState extends ErrorState {\n  ErrorBoundary: UseErrorBoundaryWrapper\n  reset: () => void\n}\n\ninterface StateAction {\n  type: \"catch\" | \"reset\"\n  error?: any | null\n}\n\n/**\n * useErrorBoundary hook options.\n */\nexport interface UseErrorBoundaryOptions {\n  /**\n   * Gets called when the ErrorBoundary catches an error.\n   *\n   * You can use this for logging or reporting errors.\n   */\n  onDidCatch?: (error: any, errorInfo: any) => void\n}\n\n/**\n * useErrorBoundary\n * React hook to use an ErrorBoundary in your component and keep track of the\n * error state of that boundary.\n *\n * Uses a wrapped class component to create the error Boundary, but uses hooks to keep the state\n * in your function component.\n */\n\ntype UseErrorBoundaryReducer = (\n  state: ErrorState,\n  action: StateAction\n) => ErrorState\n\nconst useErrorBoundaryReducer: UseErrorBoundaryReducer = (state, action) => {\n  switch (action.type) {\n    // The component did catch, update state\n    case \"catch\":\n      return {\n        didCatch: true,\n        // Pass the values from action.error\n        error: action.error,\n      }\n    case \"reset\":\n      return {\n        didCatch: false,\n        error: null,\n      }\n    // Unknown action, return state\n    default:\n      return state\n  }\n}\n\nfunction useErrorBoundary(\n  options?: UseErrorBoundaryOptions\n): UseErrorBoundaryState {\n  // Reducer handling the error state\n  const [state, dispatch] = useReducer<UseErrorBoundaryReducer>(\n    useErrorBoundaryReducer,\n    // Default state\n    {\n      didCatch: false,\n      error: null,\n    }\n  )\n  // Create ref for wrapped ErrorBoundary class\n  const errorBoundaryWrapperRef = useRef<UseErrorBoundaryWrapper | null>(null)\n\n  // Create a new wrapped boundary\n  function createWrappedErrorBoundary() {\n    // Create new wrapped ErrorBoundary class with onDidCatch callback\n    return createErrorBoundary((err, errorInfo) => {\n      // Dispatch action in case of an error\n      dispatch({\n        type: \"catch\",\n        error: err,\n      })\n\n      // call onDidCatch if provided by user\n      if (options && options.onDidCatch) options.onDidCatch(err, errorInfo)\n    })\n  }\n\n  // Get the current ref value or initialize it with a new wrapped ErrorBoundary\n  function getWrappedErrorBoundary() {\n    // Get current ref value\n    let errorBoundaryWrapper = errorBoundaryWrapperRef.current\n\n    // Return the component when already initialized\n    if (errorBoundaryWrapper !== null) {\n      return errorBoundaryWrapper\n    }\n\n    // Update the ref with new boundary\n    errorBoundaryWrapperRef.current = createWrappedErrorBoundary()\n\n    // Return the newly created component\n    return errorBoundaryWrapperRef.current\n  }\n\n  const reset = useCallback(() => {\n    // create a new wrapped boundary to force a rerender\n    errorBoundaryWrapperRef.current = createWrappedErrorBoundary()\n    // Reset the hooks error state\n    dispatch({ type: \"reset\" })\n  }, [])\n\n  // Return the wrapped ErrorBoundary class to wrap your components in plus the error state\n  return {\n    ErrorBoundary: getWrappedErrorBoundary(),\n    didCatch: state.didCatch,\n    error: state.error,\n    reset,\n  }\n}\n\nexport default useErrorBoundary\n", "import React from \"react\"\n\nimport {\n  ErrorBoundary,\n  ErrorBoundaryProps,\n  OnDidCatchCallback,\n} from \"./ErrorBoundary\"\n\n/**\n * createErrorBoundary\n * Accepts a onDidCatch callback.\n * Creates a UseErrorBoundaryWrapper HOC, to keep the onDidCatch callback while\n * still providing the ability to pass props to the ErrorBoundary\n */\n\nexport type UseErrorBoundaryWrapper = (\n  props: Omit<ErrorBoundaryProps, \"onDidCatch\">\n) => React.ReactElement\n\nexport function createErrorBoundary(\n  onDidCatch: OnDidCatchCallback\n): UseErrorBoundaryWrapper {\n  // Return function component that wraps ErrorBoundary and passes props to it\n  return function UseErrorBoundaryWrapper(props) {\n    // Return ErrorBoundary with original onDidCatch and the current props\n    return React.createElement<ErrorBoundaryProps>(ErrorBoundary, {\n      onDidCatch,\n      children: props.children,\n      render: props.render,\n      renderError: props.renderError,\n    })\n  }\n}\n"],
  "mappings": ";;;;;;;;;IAqCaA,IAAAA,SAAAA,IAAAA;AAAAA,MAAAA,IAAAA;AAOX,WAAAC,GAAYC,IAAAA;AAAAA,QAAAA;AAAAA,YACVC,KAAAA,GAAAA,KAAAA,MAAMD,EAAAA,KAAAA,MAEDE,QAAQ,EACXC,UAAAA,OACAC,OAAO,KAAA,GAAAC;EAAA;AAAA,EAAAA,KAAAC,KAAAC,KAAAR,IAAA,YAAA,OAAA,OAAAM,GAAA,SAAA,GAAAE,GAAA,UAAA,cAAAA,IAAAA,GAAA,YAAAF,IAZbP,GAmBSU,2BAAP,SAAgCJ,IAAAA;AAC9B,WAAO,EAAED,UAAAA,MAAgBC,OAAAA,GAAAA;EAAAA;AAAAA,MAAAA,KAAAA,GAAAA;AAAAA,SAAAA,GAO3BK,oBAAA,SAAkBL,IAAYM,IAAAA;AAC5B,WAAA,KAAYV,MAAMW,WAAWP,IAAOM,EAAAA;EAAAA,GAAAA,GAQtCE,SAAA,WAAA;AACE,QAAAN,KAA4BO,KAAKX,OAAAA,KACSW,KAAKb,OAAvCY,KAAAA,GAAAA,QAAQE,KAAAA,GAAAA,UAAUC,KAAAA,GAAAA;AAG1B,WAAAT,GAJQH,WAMCY,KAAcA,GAAY,EAAEX,OAAAA,GANnBA,MAAAA,CAAAA,IAM8B,OAIzCQ,KAASA,GAAAA,IAAWE,MAAY;EAAA,GAAAf;AAAA,EA/CRiB,aAAAA,aAAAA;ICW7BC,IAAmD,SAACf,IAAOgB,IAAAA;AAC/D,UAAQA,GAAOC,MAAAA;IAEb,KAAK;AACH,aAAO,EACLC,UAAAA,MAEAhB,OAAOc,GAAOd,MAAAA;IAElB,KAAK;AACH,aAAO,EACLgB,UAAAA,OACAhB,OAAO,KAAA;IAGX;AACE,aAAOF;EAAAA;AAAAA;AAIb,SAASmB,EACPC,IAAAA;AAGA,MAAAC,SAA0BC,aAAAA,YACxBP,GAEA,EACEG,UAAAA,OACAhB,OAAO,KAAA,CAAA,GALJF,IAAAA,GAAAA,CAAAA,GAAOuB,IAAAA,GAAAA,CAAAA,GASRC,QAA0BC,aAAAA,QAAuC,IAAA;AAGvE,WAASC,IAAAA;AAEP,WClEFjB,KDkE6B,SAACkB,IAAKnB,IAAAA;AAE/Be,QAAS,EACPN,MAAM,SACNf,OAAOyB,GAAAA,CAAAA,GAILP,MAAWA,GAAQX,cAAYW,GAAQX,WAAWkB,IAAKnB,EAAAA;IAAAA,GAAAA,SCvEvBV,IAAAA;AAEtC,aAAO8B,aAAAA,QAAMC,cAAkCjC,GAAe,EAC5Da,YAAAA,IACAG,UAAUd,GAAMc,UAChBF,QAAQZ,GAAMY,QACdG,aAAaf,GAAMe,YAAAA,CAAAA;IAAAA;AAAAA,QATvBJ;EAAAA;AD+FA,MAdMqB,GAcAC,QAAQC,aAAAA,aAAY,WAAA;AAExBR,MAAwBS,UAAUP,EAAAA,GAElCH,EAAS,EAAEN,MAAM,QAAA,CAAA;EAAA,GAChB,CAAA,CAAA;AAGH,SAAO,EACLrB,gBAvBIkC,IAAuBN,EAAwBS,SAGtB,SAAzBH,IACKA,KAITN,EAAwBS,UAAUP,EAAAA,GAG3BF,EAAwBS,WAa/Bf,UAAUlB,EAAMkB,UAChBhB,OAAOF,EAAME,OACb6B,OAAAA,EAAAA;AAAAA;AAAAA,IAAAA,uBAAAA;",
  "names": ["ErrorBoundary", "n", "props", "_this", "state", "hasError", "error", "e", "r", "t", "getDerivedStateFromError", "componentDidCatch", "errorInfo", "onDidCatch", "render", "this", "children", "renderError", "PureComponent", "useErrorBoundaryReducer", "action", "type", "didCatch", "useErrorBoundary", "options", "a", "useReducer", "dispatch", "errorBoundaryWrapperRef", "useRef", "createWrappedErrorBoundary", "err", "React", "createElement", "errorBoundaryWrapper", "reset", "useCallback", "current"]
}
